O que está acontecendo

No fluxo “Contas a Receber” (card do Admin Dashboard → depois você registra a entrada), o back-end está atualizando o pedido com o valor restante (ex.: 700) no campo do valor total do pedido. Resultado: o order.totalValue passa a ser 700, bagunçando o saldo e todos os agregados.

Onde está o erro

Na rota de pagamento de contas a receber:

server/routes.ts → POST /api/receivables/:id/payment

Nessa rota, depois de alocar o pagamento ao receivable, em algum ponto é chamado storage.updateOrder(...) passando o restante como se fosse o total. O nome de variável costuma ser algo como remaining/remainingAmount, e está indo para totalValue por engano.

Também vale conferir se existe a mesma confusão em um helper de atualização:

server/storage.ts → updateOrder(...)

Esse método já tem lógica para NÃO reescrever totalValue (há comentários “NUNCA alterar o valor total do pedido”). Ainda assim, se a rota mandar totalValue errado, ele salva errado.

Como corrigir (mínimo e seguro)
1) Ajuste a rota de pagamento para nunca mandar totalValue

No handler de POST /api/receivables/:id/payment, remova qualquer atribuição de totalValue e atualize apenas estes campos do pedido:

paidValue (somar o que entrou)

remainingAmount = totalValue original − paidValue atualizado

nunca toque em totalValue

Exemplo de trecho seguro dentro do handler (pseudocódigo TypeScript):

// Depois de criar o Payment e alocar no receivable:
const order = await storage.getOrderById(receivable.orderId);

// valores numéricos
const total = parseFloat(order.totalValue);
const alreadyPaid = parseFloat(order.paidValue || "0");
const thisPayment = parseFloat(amount);
const newPaid = alreadyPaid + thisPayment;
const newRemaining = Math.max(total - newPaid, 0);

// >>> NÃO enviar totalValue aqui! <<<
await storage.updateOrder(order.id, {
  paidValue: newPaid.toFixed(2),
  remainingAmount: newRemaining.toFixed(2),
  // mantenha downPayment/shipping se precisar, mas NÃO reatribua totalValue
});

2) “Trava” de segurança no updateOrder (defensiva)

No server/storage.ts, dentro de updateOrder(...), você já possui comentários para manter o total. Garanta que ignora updates.totalValue se vier junto com pagamento, algo assim:

async updateOrder(id: string, updates: Partial<Order>): Promise<Order | undefined> {
  const order = this.orders.get(id);
  if (!order) return undefined;

  // Nunca permitir que um fluxo de recebimento altere o total do pedido
  const sanitized = { ...updates };
  if ('totalValue' in sanitized && sanitized.totalValue !== undefined) {
    // só aceite mudanças de total quando forem operações explícitas (ex.: edição de orçamento)
    // Aqui, por segurança, vamos descartar quando a origem for "receivables"
    if ((sanitized as any).__origin === 'receivables') {
      delete (sanitized as any).totalValue;
    }
  }

  // ...aplique o merge mantendo order.totalValue original quando não for alteração explícita
}


Na rota, passe __origin: 'receivables' quando chamar updateOrder, só para esse guard funcionar.

3) Cálculo do card “Contas a Receber”

Garanta que o card use o saldo a receber a partir de receivables, não do order.totalValue. O correto é:

somatório( receivable.amount - receivable.receivedAmount )


Evite somar order.remainingAmount se houver risco de estar desincronizado. Se o card atual puxa de /api/finance/overview, revise o cálculo lá para usar os receivables (e não um campo do pedido que possa ter sido contaminado).