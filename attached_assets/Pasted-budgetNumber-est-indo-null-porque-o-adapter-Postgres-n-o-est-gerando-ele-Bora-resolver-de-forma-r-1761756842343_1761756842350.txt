budgetNumber está indo null porque o adapter Postgres não está gerando ele. Bora resolver de forma rápida e “à prova de erro” com dois passos: (A) hotfix no código pra já funcionar agora e (B) migração no banco pra virar padrão (mesmo se alguém esquecer no código no futuro).

A) Hotfix imediato no server/storage.pg.ts

No método createBudget, gere o budgetNumber antes do insert. Use uma sequence no Postgres (com retry se a sequence ainda não existir).

Cole/altere o método assim:

// no topo do arquivo já existe:
// import { pg } from "./pgClient";
import { sql } from "drizzle-orm";

// ...

async createBudget(budgetData: InsertBudget): Promise<Budget> {
  // 1) normalizar datas vindas como string
  const processedData: any = { ...budgetData };
  if (processedData.validUntil && typeof processedData.validUntil === "string") {
    processedData.validUntil = new Date(processedData.validUntil);
  }
  if (processedData.deliveryDeadline && typeof processedData.deliveryDeadline === "string") {
    processedData.deliveryDeadline = new Date(processedData.deliveryDeadline);
  }

  // 2) garantir SEQUENCE e gerar número único do orçamento
  async function getNextBudgetNumber(): Promise<string> {
    try {
      // tenta pegar o próximo valor
      const res: any = await pg.execute(sql`SELECT nextval('budget_number_seq') AS next`);
      const next = (Array.isArray(res) ? res[0]?.next : (res.rows?.[0]?.next)) ?? 1;

      // Formato: BUD-YYMM-000001
      const now = new Date();
      const yymm = `${String(now.getFullYear()).slice(2)}${String(now.getMonth()+1).padStart(2, '0')}`;
      return `BUD-${yymm}-${String(next).padStart(6, '0')}`;
    } catch (e) {
      // se a sequence não existir, cria e tenta de novo
      await pg.execute(sql`CREATE SEQUENCE IF NOT EXISTS budget_number_seq`);
      const res: any = await pg.execute(sql`SELECT nextval('budget_number_seq') AS next`);
      const next = (Array.isArray(res) ? res[0]?.next : (res.rows?.[0]?.next)) ?? 1;
      const now = new Date();
      const yymm = `${String(now.getFullYear()).slice(2)}${String(now.getMonth()+1).padStart(2, '0')}`;
      return `BUD-${yymm}-${String(next).padStart(6, '0')}`;
    }
  }

  if (!processedData.budgetNumber || processedData.budgetNumber === null) {
    processedData.budgetNumber = await getNextBudgetNumber();
  }

  // 3) inserir
  const results = await pg.insert(schema.budgets).values({
    ...processedData,
    createdAt: new Date(),
    updatedAt: new Date(),
  }).returning();

  return results[0];
}


Isso já elimina o erro de NOT NULL e te deixa criar/editar/converter orçamentos imediatamente.

B) Migração no banco (deixa “à prova de esquecimento”)

Depois (ou agora, se preferir), crie uma migração Drizzle que:

Cria a sequence (se não existir);

Define um DEFAULT na coluna budget_number usando a sequence — assim, mesmo que alguém não envie budgetNumber, o banco preenche.

Conteúdo da migração (ex.: drizzle/000XX_budgets_number_default.sql):