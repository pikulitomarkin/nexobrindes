ERPProdutor5.zip) e conferi o arquivo certo: client/src/pages/logistics/dashboard.tsx. A rota do back que recebe o envio individual continua ok (POST /api/orders/:id/send-to-production em server/routes.ts usa producerId certinho), entÃ£o o problema Ã© mesmo de UI/estado.

Causa provÃ¡vel do â€œtodos os botÃµes clicam/somemâ€

Mesmo vocÃª tendo isolado o botÃ£o em um componente (SendToProducerButton), havia dois pontos que fazem os botÃµes â€œandarem juntosâ€:

Compartilhamento involuntÃ¡rio de estado via mutationKey
VocÃª definiu:

const { mutate, isPending } = useMutation({
  mutationKey: [`send-to-producer-${uniqueKey}`],
  ...
})


Em listas grandes, chaves iguais ou recicladas pelo React podem fazer o React Query reconciliar o estado entre instÃ¢ncias (vocÃª jÃ¡ usa key no elemento do botÃ£o e uniqueKey tambÃ©m na linha). Na prÃ¡tica, isso pode â€œcolarâ€ o isPending entre botÃµes da mesma linha/ordem e todos passam a exibir Enviandoâ€¦ e atÃ© sumir juntos quando a lista re-renderiza apÃ³s o invalidateQueries.

Re-render apÃ³s invalidateQueries escondendo os demais
Quando um produtor recebe a OP, a lista Ã© reprocessada. Seus utilitÃ¡rios de expansÃ£o por produtor podem remontar as linhas e, somado ao ponto 1, dÃ¡ a impressÃ£o de que â€œtodos os botÃµes foram clicadosâ€ (na verdade a linha foi reconstruÃ­da e os outros produtores daquele pedido podem ter saÃ­do do primeiro grid e ido para o grid de â€œem produÃ§Ã£oâ€).

CorreÃ§Ã£o direta (segura e simples)

FaÃ§a cada botÃ£o ser 100% independente do React Query â€œglobalâ€:

Remova o mutationKey (deixe o React Query criar uma instÃ¢ncia local por botÃ£o).

Controle o â€œcarregandoâ€ com um estado local, para nÃ£o vazar pending entre itens.

Garanta que o clique do botÃ£o nÃ£o borbulha (vocÃª jÃ¡ usa stopPropagation, mantenha).

Patch (no SendToProducerButton)
function SendToProducerButton({
  orderId,
  producerId,
  label,
  uniqueKey,
}: {
  orderId: string;
  producerId: string;
  label: string;
  uniqueKey: string;
}) {
  const { toast } = useToast();
  const [pending, setPending] = useState(false);

  const { mutate } = useMutation({
    // REMOVIDO: mutationKey
    mutationFn: async () => {
      const response = await fetch(`/api/orders/${orderId}/send-to-production`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({ producerId }),
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erro ao enviar para produÃ§Ã£o');
      }
      return response.json();
    },
    onMutate: () => {
      setPending(true);
    },
    onError: (err: any) => {
      setPending(false);
      toast({
        title: 'Erro',
        description: err.message || 'Falha ao enviar para produÃ§Ã£o',
        variant: 'destructive',
      });
    },
    onSuccess: () => {
      setPending(false);
      // Atualiza os dois painÃ©is relevantes
      queryClient.invalidateQueries({ queryKey: ['/api/logistics/paid-orders'] });
      queryClient.invalidateQueries({ queryKey: ['/api/logistics/production-orders'] });
      toast({ title: 'Sucesso!', description: `Pedido enviado para ${label}` });
    },
  });

  return (
    <Button
      type="button"
      onClick={(e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!pending) mutate();
      }}
      disabled={pending}
      title={`Enviar APENAS para ${label}`}
    >
      {pending ? 'Enviando...' : `ğŸ“¤ ${label}`}
    </Button>
  );
}

Por que isso resolve

Sem mutationKey, cada botÃ£o tem sua prÃ³pria â€œmutaÃ§Ã£oâ€ e nÃ£o herda isPending dos outros.

O pending local elimina qualquer chance de outro botÃ£o â€œpegar caronaâ€ no estado.

Os invalidateQueries atualizam tanto a lista de â€œPagos, prontos para produÃ§Ã£oâ€ quanto a de â€œEm produÃ§Ã£oâ€, o que evita sumiÃ§os confusos (antes vocÃª invalidava sÃ³ production-orders).

Dois ajustes extras que recomendo

Key realmente Ãºnica na linha
VocÃª jÃ¡ usa key={send-${order.uniqueKey}-${order.currentProducerId}}. Mantenha assim (ou use key={${order.id}-${producerId}}) pra nÃ£o reciclar instÃ¢ncias na troca de filtros.

Parar clique no botÃ£o â€œVer Produtor/Pedidoâ€ tambÃ©m
JÃ¡ estÃ¡ com stopPropagation, mantenha. Assim abrir modal nÃ£o dispara nada no container da linha.

Checklist de teste (rapidinho)

Pedido com 2+ produtores aparece com um botÃ£o por produtor.

Clicar em apenas 1 mostra â€œEnviandoâ€¦â€ somente naquele botÃ£o.

ApÃ³s sucesso:

Aquele produtor some da lista de â€œPagos/Prontosâ€ e aparece em â€œEm ProduÃ§Ã£oâ€.

Os outros produtores do mesmo pedido continuam na lista com seus botÃµes ativos.

Nenhum outro botÃ£o entra em â€œEnviandoâ€¦