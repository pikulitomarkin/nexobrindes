O que está quebrando

O front chama estes endpoints para a conciliação OFX:

GET /api/finance/bank-transactions

GET /api/finance/reconciliation

POST /api/finance/ofx-import (upload do OFX)

POST /api/finance/associate-payment

POST /api/finance/associate-multiple-payments

No teu server/routes.ts:

Os POST já existem (importar OFX e associar pagamentos ✅).

Faltam os GET para listar as transações bancárias e para o resumo de conciliação.
Por isso o front “não lista as entradas pra conciliar” e “não habilita” nada — ele fica sem dados.

Correção (colando no server/routes.ts)

Cola estes blocos dentro da função registerRoutes(app: Express) (onde estão os demais app.get/app.post). Eles usam as funções já expostas no storage.ts (getBankTransactions, getOrders, etc.).

// [1] Lista transações bancárias para conciliação (com filtros opcionais)
app.get("/api/finance/bank-transactions", async (req, res) => {
  try {
    // Filtros opcionais via query: ?status=unmatched|matched & type=credit|debit
    const { status, type } = req.query as { status?: string; type?: string };

    const all = await storage.getBankTransactions(); // vem do storage.ts
    const normalized = (all || []).map(tx => ({
      id: tx.id,
      importId: tx.importId || null,
      fitId: tx.fitId || null,
      date: tx.date,
      hasValidDate: !!tx.hasValidDate,
      amount: typeof tx.amount === "string" ? tx.amount : String(tx.amount),
      description: tx.description || "",
      memo: tx.memo || "",
      bankRef: tx.bankRef || "",
      originalType: tx.originalType || "",
      type: tx.type || (parseFloat(tx.amount) >= 0 ? "credit" : "debit"),
      status: tx.status || "unmatched",
      matchedOrderId: tx.matchedOrderId || null,
      matchedPaymentId: tx.matchedPaymentId || null,
      matchedAt: tx.matchedAt || null,
      notes: tx.notes || "",
    }));

    const filtered = normalized.filter(tx => {
      const okStatus = status ? tx.status === status : true;
      const okType   = type ? tx.type   === type   : true;
      return okStatus && okType;
    });

    res.json(filtered);
  } catch (err: any) {
    console.error("Error fetching bank transactions:", err);
    res.status(500).json({ error: "Failed to fetch bank transactions" });
  }
});

// [2] Resumo de conciliação (usado só para carregar o painel sem skeleton travar)
app.get("/api/finance/reconciliation", async (req, res) => {
  try {
    const [txs, orders] = await Promise.all([
      storage.getBankTransactions(),
      storage.getOrders(),
    ]);

    const totalTx = txs?.length || 0;
    const matched = txs?.filter(t => t.status === "matched").length || 0;
    const unmatched = totalTx - matched;

    const pendingOrders = (orders || []).filter(o => {
      const total = parseFloat(o.totalValue || "0");
      const paid  = parseFloat(o.paidValue  || "0");
      const remaining = total - paid;
      return o.status !== "cancelled" && remaining > 0.01;
    });

    const totalRemaining = pendingOrders.reduce((acc, o) => {
      const total = parseFloat(o.totalValue || "0");
      const paid  = parseFloat(o.paidValue  || "0");
      return acc + (total - paid);
    }, 0);

    res.json({
      bank: { total: totalTx, matched, unmatched },
      orders: { pendingCount: pendingOrders.length, totalRemaining: Number(totalRemaining.toFixed(2)) },
      lastUpdated: new Date().toISOString(),
    });
  } catch (err: any) {
    console.error("Error building reconciliation summary:", err);
    res.status(500).json({ error: "Failed to build reconciliation summary" });
  }
});


Esses dois endpoints são exatamente os que o front espera (eu conferi no teu client/src/pages/finance/reconciliation.tsx e client/src/pages/admin/producer-payments.tsx). Assim que eles existirem:

Ao importar o OFX, as transações vão aparecer na lista.

Os cartões e botões de “conciliar” serão habilitados, pois a lógica do front filtra por status === 'unmatched' e type === 'credit' (recebíveis) ou usa o mesmo endpoint na tela de Pagamento ao Produtor (onde dá pra filtrar por type=debit via query se quiser).