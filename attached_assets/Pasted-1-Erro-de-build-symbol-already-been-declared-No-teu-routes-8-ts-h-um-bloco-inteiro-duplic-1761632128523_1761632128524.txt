1) Erro de build (â€œsymbol â€¦ already been declaredâ€)

No teu routes (8).ts hÃ¡ um bloco inteiro duplicado lÃ¡ no final â€” por isso o esbuild acusa:

upload declarado 2x

requireAuth declarado 2x

parseOFXBuffer declarado 2x

generateId declarado 2x

e uma segunda registerRoutes (dupla exportaÃ§Ã£o)

Como corrigir (simples e definitivo)

Remova o bloco duplicado que comeÃ§a ali perto de:

Linha ~6330: const upload = multer({ ... })

e engloba a segunda registerRoutes que inicia em ~6546

vai atÃ© o fim do arquivo.

Em resumo: delete de ~6330 atÃ© o fim do arquivo.
(Esse bloco Ã© cÃ³pia do primeiro, sÃ³ que repetido; manter apenas a primeira definiÃ§Ã£o elimina todos os â€œalready been declaredâ€.)

Se preferir granular:

Apague as segundas declaraÃ§Ãµes de upload, requireAuth, parseOFXBuffer, generateId e toda a segunda registerRoutes.

ApÃ³s isso, o comando tsx server/index.ts deve subir sem esse erro.

2) â€œEntradaâ€ dobrando no Contas a Receber (R$ 1.800 vira R$ 3.600)

O que encontrei:

O endpoint POST /api/receivables/:id/payment existe duas vezes no arquivo (duplicado), e alÃ©m disso, na versÃ£o que estÃ¡ valendo ele nÃ£o cria um â€œPaymentâ€ quando o tÃ­tulo Ã© vinculado a um pedido (recebÃ­vel â€œde pedidoâ€).

Resultado tÃ­pico quando a tela dispara chamadas em sequÃªncia ou quando endpoints duplicados ficam ativos: vocÃª registra a entrada e o lado que recalcula o paidValue roda mais de uma vez / caminhos diferentes atualizam o mesmo saldo â†’ aparenta â€œdobrarâ€.

O que vamos fazer

Eliminar as rotas duplicadas (passo 1 acima jÃ¡ resolve a parte de â€œduas rotas rodandoâ€).

Ajustar a rota Ãºnica POST /api/receivables/:id/payment para que, quando o receivable pertencer a um pedido (receivable.orderId), ela:

crie um Payment confirmado para esse pedido (com method: 'manual', status: 'confirmed');

use um transactionId idempotente (se informado pelo front, evitar duplicata; se nÃ£o, gerar um);

recalcule o paidValue via updateOrderPaidValue(orderId) apenas uma vez.

Guardar idempotÃªncia no storage: se jÃ¡ houver Payment com o mesmo transactionId para o pedido, nÃ£o criar de novo.

Patch no backend
(A) Em storage (4).ts â€” util pra idempotÃªncia:

Adicione estes mÃ©todos (ou equivalentes no teu repositÃ³rio/DAO):

// Listar pagamentos (jÃ¡ existe getPayments, senÃ£o ajuste)
async getPayments(): Promise<Payment[]> {
  return Array.from(this.payments.values());
}

// Buscar payment por transactionId (idempotÃªncia)
async getPaymentByTransactionId(txId: string): Promise<Payment | undefined> {
  return Array.from(this.payments.values()).find(p => p.transactionId === txId);
}


E, se quiser ser Ã  prova de clique-duplo, no prÃ³prio createPayment:

async createPayment(insertPayment: InsertPayment): Promise<Payment> {
  if (insertPayment.transactionId) {
    const dup = await this.getPaymentByTransactionId(insertPayment.transactionId);
    if (dup) return dup; // idempotente
  }
  // ... resto do mÃ©todo como jÃ¡ estÃ¡
}

(B) Em routes (8).ts â€” dentro da primeira registerRoutes (a que fica no inÃ­cio do arquivo), substitua o corpo da rota POST /api/receivables/:id/payment por algo assim:
app.post("/api/receivables/:id/payment", async (req, res) => {
  try {
    const { id } = req.params;
    const { amount, method, transactionId, notes } = req.body;

    const value = Number.parseFloat(String(amount).replace(",", "."));
    if (!Number.isFinite(value) || value <= 0) {
      return res.status(400).json({ error: "Valor deve ser maior que zero" });
    }

    const receivables = await storage.getAccountsReceivable();
    const receivable = receivables.find(r => r.id === id);
    if (!receivable) {
      return res.status(404).json({ error: "Conta a receber nÃ£o encontrada" });
    }

    let paymentRecord: any = null;

    if (receivable.orderId) {
      // ğŸ’¡ IDMP: se vier um transactionId do front, nÃ£o duplica
      if (transactionId) {
        const existing = await storage.getPaymentByTransactionId(transactionId);
        if (existing) {
          await storage.updateOrderPaidValue(receivable.orderId);
          return res.json({ success: true, payment: existing, idempotent: true });
        }
      }

      // Cria um Payment confirmado para o pedido (manual)
      const payment = await storage.createPayment({
        orderId: receivable.orderId,
        amount: value.toFixed(2),
        method: method || "manual",
        status: "confirmed",
        transactionId: transactionId || `MAN-${Date.now()}`,
        reconciliationStatus: "manual",
        paidAt: new Date()
      });

      // Atualiza o paidValue a partir dos Payments confirmados
      await storage.updateOrderPaidValue(receivable.orderId);
      paymentRecord = payment;

    } else {
      // RecebÃ­vel manual (nÃ£o vinculado a pedido): sÃ³ somar no tÃ­tulo
      const current = Number.parseFloat(String(receivable.receivedAmount || "0"));
      const updated = await storage.updateAccountsReceivable(id, {
        receivedAmount: (current + value).toFixed(2),
        status: (current + value) >= Number.parseFloat(String(receivable.amount))
          ? "paid"
          : ((current + value) > 0 ? "partial" : "pending")
      });

      paymentRecord = {
        id: `payment-${Date.now()}`,
        amount: value.toFixed(2),
        method: method || "manual",
        transactionId: transactionId || `MAN-${Date.now()}`,
        notes: notes || "",
        paidAt: new Date(),
        receivable: updated.id
      };
    }

    return res.json({ success: true, payment: paymentRecord });

  } catch (error: any) {
    console.error("Error processing receivables payment:", error);
    return res.status(500).json({ error: "Erro ao processar pagamento: " + error.message });
  }
});


Isso garante que apenas um caminho atualiza o saldo:
â€¢ para pedido â†’ via Payments confirmados (e o updateOrderPaidValue consolida);
â€¢ para tÃ­tulo manual â†’ via receivedAmount do prÃ³prio receivable.
Com a idempotÃªncia, um clique duplo ou repetiÃ§Ã£o de requisiÃ§Ã£o nÃ£o duplica o pagamento.