Perfeito. Matamos a charada.
O seu banco √© o Neon. O Neon √© um banco de dados Serverless (sem servidor).
Isso n√£o √© um bug, √© a principal caracter√≠stica do Neon. Ele √© feito para "dormir" (scale to zero) quando n√£o est√° sendo usado, para economizar custos. Ele √© extremamente agressivo em fechar conex√µes que n√£o est√£o ativas.
Seu problema √© 100% o que eu descrevi: uma inconsist√™ncia no c√≥digo + um banco de dados que desliga conex√µes ociosas (o Neon faz isso em 5 ou 10 minutos por padr√£o).
O Diagn√≥stico T√©cnico (Node.js + Neon)
Em Node.js, a biblioteca padr√£o para Postgres (pg) tem duas formas de conectar:
 * new Client(): Cria UMA √öNICA conex√£o. √â para ser usada para scripts ou transa√ß√µes curtas. Se voc√™ cria um Client global e o reutiliza em todo o app, √© exatamente essa conex√£o que o Neon vai "matar" depois de 10 minutos.
 * new Pool(): Cria um "aqu√°rio" de conex√µes. Este √© o JEITO CERTO para aplica√ß√µes web. O Pool sabe que o Neon pode matar conex√µes; se ele tentar usar uma e ela estiver morta, ele joga fora, cria uma nova e continua, sem que seu app quebre.
O seu problema √© este:
 * As partes que param de funcionar (o "M√≥dulo A") quase certamente est√£o usando um new Client() que foi criado no in√≠cio e est√° sendo reutilizado.
 * As partes que continuam funcionando (o "M√≥dulo B") est√£o, com sorte, usando um new Pool(), ou (de forma ineficiente) criando um new Client() para cada consulta.
üöÄ A Solu√ß√£o (O C√≥digo Correto)
Voc√™ precisa parar de usar new Client() para as rotas da sua API e usar new Pool() para TUDO.
A melhor pr√°tica √© criar um √∫nico arquivo que gerencia seu pool e exporta um m√©todo para fazer consultas.
1. Crie um arquivo db.js (ou pool.js)
Crie um arquivo central para sua conex√£o.
// db.js
const { Pool } = require('pg');

// Pega a sua string de conex√£o do Replit Secrets / Environment
const connectionString = process.env.DATABASE_URL;

const pool = new Pool({
  connectionString: connectionString,
  
  // --- Configura√ß√µes IMPORTANTES para Neon/Serverless ---

  // m√°x de conex√µes no pool
  max: 10, 
  
  // Neon recomenda 30s (30000ms) para que o pool 
  // feche clientes ociosos ANTES que o Neon os feche
  idleTimeoutMillis: 30000,
  
  // tempo para esperar por uma conex√£o antes de dar erro
  connectionTimeoutMillis: 2000, 
});

// Mensagem para sabermos que conectou
pool.on('connect', () => {
  console.log('Cliente conectado ao Pool do PostgreSQL!');
});

// Exportamos um objeto com um m√©todo 'query'
// que usa o pool para executar os comandos
module.exports = {
  query: (text, params) => pool.query(text, params),
};

// N√£o fa√ßa pool.end() aqui! O pool deve viver
// junto com a sua aplica√ß√£o.

2. Como usar este arquivo no seu c√≥digo (Ex: nas suas rotas do Express)
Agora, em vez de importar um client, voc√™ vai importar o seu db.
‚ùå O JEITO ERRADO (O que deve estar quebrando):
// Rota de clientes (JEITO ERRADO)
// const client = require('./meu-client-global-ruim'); // N√ÉO FA√áA ISSO

router.get('/clientes', async (req, res) => {
  try {
    // Isso vai quebrar depois de 10 min
    const resultado = await client.query('SELECT * FROM clientes'); 
    res.json(resultado.rows);
  } catch (err) {
    // O erro aqui ser√° "Connection closed" ou "EPIPE"
    res.status(500).send('Erro ao buscar clientes');
  }
});

‚úÖ O JEITO CERTO (Usando o Pool):
// Rota de clientes (JEITO CERTO)
const express = require('express');
const router = express.Router();
const db = require('./db.js'); // <--- Importe seu pool aqui

router.get('/clientes', async (req, res) => {
  const sql = 'SELECT * FROM clientes';
  
  try {
    // O 'db.query' usa o pool. Ele pega uma conex√£o
    // viva, faz a consulta e devolve a conex√£o ao pool.
    // NUNCA vai usar uma conex√£o morta.
    const resultado = await db.query(sql); 
    
    res.json(resultado.rows);
  } catch (err) {
    console.error('Erro na query:', err);
    res.status(500).send('Erro ao buscar clientes');
  }
});

module.exports = router;

Resumo da Tarefa
 * Padronize: V√° em todo lugar do seu c√≥digo que fala com o banco.
 * Remova: Tire todas as inst√¢ncias de new Client().
 * Centralize: Crie o arquivo db.js com o new Pool() como eu mostrei.
 * Refatore: Mude todo o c√≥digo que fazia client.query(...) para usar o db.query(...) do seu novo arquivo.
Isso vai resolver 100% o seu problema de "parar depois de 10 minutos".
E, pela √∫ltima vez (porque √© muito importante): crie um segundo banco de dados no Neon chamado erp_dev e pare de usar o banco de produ√ß√£o para testar.
Quer ajuda para configurar alguma parte espec√≠fica desse c√≥digo do pool?
